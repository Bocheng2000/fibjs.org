
/*! @brief 纤程操作对象，此对象不可直接创建
    @brief Fiber operation object, this object cannot be created directly.

 Function.start 或 coroutine.start 创建纤程后，将返回此对象，用于纤程处理和纤程间通信。
 This object, which is used to issue fibers and communications between fibers, will be returned after the fiber is created by Function.start or coroutine.start.
 纤程主函数可以通过 this 访问本纤程对象，也可通过 coroutine.current 获取当前纤程。
 Fiber's main function can access the fiber by this, or get the fiber by coroutine.current.
 @code
 function func(v1)
 {
   console.log(v1 + this.v);
 }

 var fb = func.start(100);

 fb.v = 123;

 fb.join();
 @endcode

 纤程局部存储通过共享的 Fiber 对象完成，通过 coroutine.current 获取当前纤程，通过修改和查询其变量达到共享数据的目的。
 Fiber Local Storage is done by the shared Fiber object. Current fiber can be accessed by coroutine.current, and the data can be shared by querying and modifying the fiber's variables.

 @code
 function func()
 {
   console.log(coroutine.current().v);
 }

 coroutine.current().v = 100;

 func();
 @endcode

 纤程在创建时，会自动复制当前纤程的局部变量到新的纤程，之后，各自的局部变量的修改不会相互影响，除非变量本身为对象引用。
 When a new fiber is created, the current fiber's local variables will be copied to the new fiber.
 After that, each fiber's local variables won't have any effect on other's, unless the variable is referenced by other objects.

 @code
 function func()
 {
   console.log(coroutine.current().v);
 }

 coroutine.current().v = 100;

 var fb = func.start();

 coroutine.current().v = 200;

 fb.join();
 @endcode
 */
interface Fiber : object
{
    /*! @brief 等待纤程结束 
        @brief waiting until the end of the fiber
    */
    join();

    /*! @brief 查询纤程的调用纤程 
        @brief querying the fiber's caller
    */
    readonly Fiber caller;
};
